
import numpy as np
import pandas as pd
from dm_control import mujoco
from dm_control.mujoco.wrapper.core import set_callback, MjModel, MjData

# Read fluid field data
df = pd.read_csv('fluid_velocity_data.csv')
velocities = {}
for index, row in df.iterrows():
    key = (row['X [ m ]'], row['Y [ m ]'], row['Z [ m ]'])
    velocities[key] = np.array([row['Velocity u [ m s^-1 ]'], row['Velocity v [ m s^-1 ]'], row['Velocity w [ m s^-1 ]']])

# Fluid parameters
fluid_density = 1050 # kg/m^3
dynamic_viscosity = 0.0035 # Pa.s

def calculate_forces_3D(velocities, object_position, object_velocity, object_area, object_normal):
    # Get the local fluid velocity
    local_fluid_velocity = velocities.get(tuple(object_position), np.array([0, 0, 0]))
    # Compute the relative velocity between object and fluid
    relative_velocity = object_velocity - local_fluid_velocity
    relative_speed = np.linalg.norm(relative_velocity)
    # Calculate the Reynolds number
    reynolds_number = (fluid_density * relative_speed * np.sqrt(object_area)) / dynamic_viscosity
    # Determine the drag coefficient based on Reynolds number
    drag_coefficient = 0.47 if reynolds_number < 2000 else 0.1
    # Calculate the drag force
    drag_force = 0.5 * fluid_density * relative_speed ** 2 * drag_coefficient * object_area * -relative_velocity / relative_speed
    # Calculate the lift direction
    lift_direction = np.cross(relative_velocity, object_normal)
    lift_direction = lift_direction / np.linalg.norm(lift_direction) if np.linalg.norm(lift_direction) != 0 else np.zeros(3)
    # Calculate the lift force
    lift_force = 0.5 * fluid_density * relative_speed ** 2 * drag_coefficient * object_area * lift_direction
    # Calculate the total force acting on the object
    total_force = drag_force + lift_force
    return total_force

# Global variable to count how many times the callback function has been called
callback_called = 0  

def custom_fluid(model: MjModel, data: MjData):
    global callback_called

    # Get the position and velocity of the object.[Need the slice_index] 
    object_position = data.qpos
    object_velocity = data.qvel

    # Object surface area and normal direction 
    object_area = 0.01  # in m^2
    object_normal = np.array([0, 0, 1])  # unit vector

    # Calculate fluid forces
    fluid_force = calculate_forces_3D(velocities, object_position, object_velocity, object_area, object_normal)
    
    # Apply fluid forces to the simulation.
    data.xfrc_applied[pasive_force, :3] = fluid_force
    
    callback_called += 1  # Increment the callback counter
